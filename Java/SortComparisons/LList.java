public class LList<T> implements ListInterface<T>{	private Node firstNode; // reference to first node	private Node lastNode;	// reference to last node  	private int  length;    // number of entries in list  	public LList()  	{		clear();  	} // end default constructor  		// step backwards through the array and add(1, length - index) for each item in the array  	public LList(T[] argArray)  	{	clear();  		for(int i = argArray.length -1; i >= 0; i--)  		{	add(1, argArray[i]);  		}  	}  	public boolean add(T newEntry)  	{	  	Node newNode = new Node(newEntry);	  	if (isEmpty())	  		firstNode = newNode;	  	else                       // add to end of nonempty list	  	{			lastNode.next = newNode; // make last node reference new node	   	} // end if	   	lastNode = newNode;	   	length++;	   	return true;   	} // end add   	public boolean add(int newPosition, T newEntry)   	{     	boolean isSuccessful = true;     	if ((newPosition >= 1) && (newPosition <= length+1))     	{			Node newNode = new Node(newEntry);       		if (isEmpty() || (newPosition == 1)) // case 1       		{       			newNode.next = firstNode;         		firstNode = newNode;       		}       		else                                 // case 2: list is not empty       		{									// and newPosition > 1         		Node nodeBefore = getNodeAt(newPosition - 1);         		Node nodeAfter = nodeBefore.next;         		newNode.next = nodeAfter;         		nodeBefore.next = newNode;       		} // end if       		length++;       		if (newPosition == length)       		{	lastNode = newNode; }     	}     	else       		isSuccessful = false;     	return isSuccessful;     } // end add	public T remove(int givenPosition)	{	  	T result = null;                 // return value	  	if ((givenPosition >= 1) && (givenPosition <= length))	  	{	    	assert !isEmpty();	    	if (givenPosition == 1)        // case 1: remove first entry	    	{	      		result = firstNode.data;     // save entry to be removed	      		firstNode = firstNode.next;	    	}	    	else                           // case 2: givenPosition > 1	    	{	      		Node nodeBefore = getNodeAt(givenPosition - 1);	      		Node nodeToRemove = nodeBefore.next;	      		Node nodeAfter = nodeToRemove.next;	      		nodeBefore.next = nodeAfter;  // disconnect the node to be removed	      		result = nodeToRemove.data;  // save entry to be removed	      		if (givenPosition == length)	      			lastNode = nodeBefore;	    	} // end if	    	length--;	  	} // end if	  	return result;                   // return removed entry, or	                                     // null if operation fails    } // end remove    public boolean remove(T anObject)	{		Node current = firstNode;		boolean successful = false;		if( firstNode.data.equals(anObject))			// if we need to remove the first entry		{	firstNode = firstNode.next;			successful = true;			length--;		}		while( !successful && current.next != null)		// while there are points left to search		{	if( current.next.data.equals(anObject))	// check the next data point			{	current.next = current.next.next;	// remove it if match is found				successful = true;				length--;				if(current.next == null)	// if this is now the last node in the list					lastNode = current;			}			current = current.next;		}		return successful;	}  	public final void clear()  	{  		firstNode = null;  		lastNode = null;    	length = 0;  	} // end clear	public boolean replace(int givenPosition, T newEntry)	{	  	boolean isSuccessful = true;	  	if ((givenPosition >= 1) && (givenPosition <= length))	  	{	    	assert !isEmpty();	    	Node desiredNode = getNodeAt(givenPosition);	    	desiredNode.data = newEntry;	  	}	  	else	    	isSuccessful = false;	  	return isSuccessful;    } // end replace    public T replaceNreturn(int replacePos, T replaceWith)	{	T toReturn = null;		if( replacePos <= length && replacePos >= 1)		{	toReturn = getNodeAt(replacePos).data;			getNodeAt(replacePos).data = replaceWith;		}		return toReturn;	}	public T getEntry(int givenPosition)	{		T result = null; // result to return		if ((givenPosition >= 1) && (givenPosition <= length))     	{       		assert !isEmpty();       		result = getNodeAt(givenPosition).data;     	} // end if		return result;	} // end getEntry	public int getPosition(T anObject)	{		int toReturn = -1;		int index = 1;		Node current = firstNode;		while( toReturn < 0 && index <= length)	// escape loop on first match or no matches		{	if( anObject.equals(current.data) )			{	toReturn = index;			}			else			{	current = current.next;				index++;			}		}		return toReturn;	}	public boolean contains(T anEntry)	{	  	boolean found = false;	  	Node currentNode = firstNode;	  	while (!found && (currentNode != null))	  	{	    	if (anEntry.equals(currentNode.data))	      		found = true;	    	else	      		currentNode = currentNode.next;	  	} // end while	  	return found;    } // end contains    public int getLength ()	{		return length;	}   	public boolean isEmpty()   	{     	boolean result;     	if (length == 0)     	{       		assert firstNode == null;       		result = true;     	}     	else     	{       		assert firstNode != null;       		result = false;     	} // end if     	return result;    } // end isEmpty	public boolean isFull ()	{		return false;	}   	public void display()   	{     	Node currentNode = firstNode;     	while (currentNode != null)     	{     		System.out.print(currentNode.data + " ");       		currentNode = currentNode.next;     	} // end while     	System.out.println();     } // end display    public boolean equals(LList<T> argList)	{		boolean toReturn = true;		Node current = firstNode;		int index = 1;		if( length != argList.getLength() )			toReturn = false;		else		{	while( toReturn == true && index <= length )			{	toReturn = current.data.equals(argList.getEntry(index));					// toReturn is still true if current.data equals argList's equivalent data field					// once a comparison comes back false, the loop exits and returns a false				current = current.next;				index++;			}		}		return toReturn;	}	// ---------------private!-----------------------------    /** Task: Returns a reference to the node at a given position.     *  Precondition: List is not empty; 1 <= givenPosition <= length. */	private Node getNodeAt(int givenPosition)	{  		assert !isEmpty() && (1 <= givenPosition) && (givenPosition <= length);  		Node currentNode = firstNode;		if (givenPosition == length)			currentNode = lastNode;		else  		{	// traverse the list to locate the desired node  			for (int counter = 1; counter < givenPosition; counter++)    			currentNode = currentNode.next;		}  		assert currentNode != null;  		return currentNode;	} // end getNodeAt	private class Node	{		private T    data; // entry in list   		private Node next; // link to next node   		private Node(T dataPortion)   		{    	 	data = dataPortion;    	 	next = null;   		} // end constructor   		private Node(T dataPortion, Node nextNode)   		{    	 	data = dataPortion;    	 	next = nextNode;   		} // end constructor	} // end Node}// end LList